#include <stdint.h>
#include <stdbool.h>
#include "uart.h"

#define PCI_IOBASE 0x30000000  // 0x30000000UL

uint32_t pci_config_read32(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) {
    uint32_t address;
    uint32_t word;
    volatile uint32_t* config_addr;

    // Compute MMIO address as per PCI config space layout
    address = PCI_IOBASE
            + ((uint32_t)bus << 20)    // 256 buses
            + ((uint32_t)slot << 15)   // 32 devices
            + ((uint32_t)func << 12)   // 8 functions
            + (offset & ~0x3);       // aligned to 4 bytes
    config_addr = (volatile uint32_t *)address;
    word = *config_addr; // read full 32-bit word
    return word;
}

void pci_config_write32(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset, uint32_t data) {
    uint32_t address;
    volatile uint32_t* config_addr;

    // Compute MMIO address as per PCI config space layout
    address = PCI_IOBASE
            + ((uint32_t)bus << 20)    // 256 buses
            + ((uint32_t)slot << 15)   // 32 devices
            + ((uint32_t)func << 12)   // 8 functions
            + (offset & ~0x3);       // aligned to 4 bytes
    config_addr = (volatile uint32_t *)address;
    *config_addr = data; // write full 32-bit word
}

struct pci_dev {
	uint8_t bus;
	uint8_t slot;
	uint8_t devfn;
	unsigned short	vendor;
	unsigned short	device;
};

size_t pci_resource_len(struct pci_dev* dev, uint8_t BAR){
	uint8_t bar_offet = 0x10 + 4*BAR;
	uint32_t bar_word = pci_config_read32(dev->bus, dev->slot, dev->devfn, bar_offet);
	uint32_t saved_bar = bar_word;
	pci_config_write32(dev->bus, dev->slot, dev->devfn, bar_offet, ~0);
	bar_word = pci_config_read32(dev->bus, dev->slot, dev->devfn, bar_offet) & (~0b1111);
	bar_word = (~bar_word) + 1;
	pci_config_write32(dev->bus, dev->slot, dev->devfn, bar_offet, saved_bar);
	return bar_word;
}

#define VRAM_BASE (0x50000000)
#define MMIO_BASE (0x40000000)

volatile uint8_t* VRAM = (volatile uint8_t*)VRAM_BASE;
volatile uint8_t* MMIO = (volatile uint8_t*)MMIO_BASE;

typedef struct mode13h_reg_t{
    uint8_t address;
    uint8_t index;
    uint8_t data;
}mode13h_reg_t;

mode13h_reg_t mode_13h_regs[] = {
	// Miscellaneous Output Register:
	// Just a single port.
	// But bit 0 determines whether we use 3Dx or 3Bx.
	// So we need to set this early.
	{0xC2, 0xFF, 0x63},

	// Sequencer:
	// Disable reset here.
	{0xC4, 0x00, 0x00},

	// Attributes:
	// - Read 3DA to reset flip-flop
	// - Write 3C0 for address
	// - Write 3C0 for data
	{0xC0, 0x00, 0x00},
	{0xC0, 0x01, 0x02},
	{0xC0, 0x02, 0x08},
	{0xC0, 0x03, 0x0A},
	{0xC0, 0x04, 0x20},
	{0xC0, 0x05, 0x22},
	{0xC0, 0x06, 0x28},
	{0xC0, 0x07, 0x2A},
	{0xC0, 0x08, 0x15},
	{0xC0, 0x09, 0x17},
	{0xC0, 0x0A, 0x1D},
	{0xC0, 0x0B, 0x1F},
	{0xC0, 0x0C, 0x35},
	{0xC0, 0x0D, 0x37},
	{0xC0, 0x0E, 0x3D},
	{0xC0, 0x0F, 0x3F},

	{0xC0, 0x30, 0x41},
	{0xC0, 0x31, 0x00},
	{0xC0, 0x32, 0x0F},
	{0xC0, 0x33, 0x00},
	{0xC0, 0x34, 0x00},

	// Graphics Mode
	{0xCE, 0x00, 0x00},
	{0xCE, 0x01, 0x00},
	{0xCE, 0x02, 0x00},
	{0xCE, 0x03, 0x00},
	{0xCE, 0x04, 0x00},
	{0xCE, 0x05, 0x40},
	{0xCE, 0x06, 0x05},
	{0xCE, 0x07, 0x00},
	{0xCE, 0x08, 0xFF},

	// CRTC
	{0xD4, 0x11, 0x0E}, // Do this to unprotect the registers

	{0xD4, 0x00, 0x5F},
	{0xD4, 0x01, 0x4F},
	{0xD4, 0x02, 0x50},
	{0xD4, 0x03, 0x82},
	{0xD4, 0x04, 0x54},
	{0xD4, 0x05, 0x80},
	{0xD4, 0x06, 0xBF},
	{0xD4, 0x07, 0x1F},
	{0xD4, 0x08, 0x00},
	{0xD4, 0x09, 0x41},
	{0xD4, 0x0A, 0x20},
	{0xD4, 0x0B, 0x1F},
	{0xD4, 0x0C, 0x00},
	{0xD4, 0x0D, 0x00},
	{0xD4, 0x0E, 0xFF},
	{0xD4, 0x0F, 0xFF},
	{0xD4, 0x10, 0x9C},
	{0xD4, 0x11, 0x8E}, // Registers are now reprotected
	{0xD4, 0x12, 0x8F},
	{0xD4, 0x13, 0x28},
	{0xD4, 0x14, 0x40},
	{0xD4, 0x15, 0x96},
	{0xD4, 0x16, 0xB9},
	{0xD4, 0x17, 0xA3},

	// Sequencer
	{0xC4, 0x01, 0x01},
	{0xC4, 0x02, 0x0F},
	{0xC4, 0x03, 0x00},
	{0xC4, 0x04, 0x0E},

	{0x00, 0x00, 0x00}
};



uint8_t read8u(uint32_t addr){
    uint8_t value;
    __asm__ volatile ("lbu %0, 0(%1)" :: "r"(value), "r"(addr): "memory");
    return value;
}

int8_t read8(uint32_t addr){
    int8_t value;
    __asm__ volatile ("lb %0, 0(%1)" :: "r"(value), "r"(addr): "memory");
    return value;
}


int16_t read16(uint32_t addr){
    int16_t value;
    __asm__ volatile ("lh %0, 0(%1)" :: "r"(value), "r"(addr): "memory");
    return value;
}


uint16_t read16u(uint32_t addr){
    uint16_t value;
    __asm__ volatile ("lhu %0, 0(%1)" :: "r"(value), "r"(addr): "memory");
    return value;
}

void write8(uint32_t addr, uint8_t value){
    __asm__ volatile ("sb %0, 0(%1)" :: "r"(value), "r"(addr): "memory");
}

void write16(uint32_t addr, uint16_t value){
    __asm__ volatile ("sh %0, 0(%1)" :: "r"(value), "r"(addr): "memory");
}

uint8_t initial_palette[] = {
	0x00, 0x00, 0x00,
	0x00, 0x00, 0x55,
	0x00, 0x00, 0xAA,
	0x00, 0x00, 0xFF,
	0x00, 0x55, 0x00,
	0x00, 0x55, 0x55,
	0x00, 0x55, 0xAA,
	0x00, 0x55, 0xFF,
	0x00, 0xAA, 0x00,
	0x00, 0xAA, 0x55,
	0x00, 0xAA, 0xAA,
	0x00, 0xAA, 0xFF,
	0x00, 0xFF, 0x00,
	0x00, 0xFF, 0x55,
	0x00, 0xFF, 0xAA,
	0x00, 0xFF, 0xFF,
	0x55, 0x00, 0x00,
	0x55, 0x00, 0x55,
	0x55, 0x00, 0xAA,
	0x55, 0x00, 0xFF,
	0x55, 0x55, 0x00,
	0x55, 0x55, 0x55,
	0x55, 0x55, 0xAA,
	0x55, 0x55, 0xFF,
	0x55, 0xAA, 0x00,
	0x55, 0xAA, 0x55,
	0x55, 0xAA, 0xAA,
	0x55, 0xAA, 0xFF,
	0x55, 0xFF, 0x00,
	0x55, 0xFF, 0x55,
	0x55, 0xFF, 0xAA,
	0x55, 0xFF, 0xFF,
	0xAA, 0x00, 0x00,
	0xAA, 0x00, 0x55,
	0xAA, 0x00, 0xAA,
	0xAA, 0x00, 0xFF,
	0xAA, 0x55, 0x00,
	0xAA, 0x55, 0x55,
	0xAA, 0x55, 0xAA,
	0xAA, 0x55, 0xFF,
	0xAA, 0xAA, 0x00,
	0xAA, 0xAA, 0x55,
	0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xFF,
	0xAA, 0xFF, 0x00,
	0xAA, 0xFF, 0x55,
	0xAA, 0xFF, 0xAA,
	0xAA, 0xFF, 0xFF,
	0xFF, 0x00, 0x00,
	0xFF, 0x00, 0x55,
	0xFF, 0x00, 0xAA,
	0xFF, 0x00, 0xFF,
	0xFF, 0x55, 0x00,
	0xFF, 0x55, 0x55,
	0xFF, 0x55, 0xAA,
	0xFF, 0x55, 0xFF,
	0xFF, 0xAA, 0x00,
	0xFF, 0xAA, 0x55,
	0xFF, 0xAA, 0xAA,
	0xFF, 0xAA, 0xFF,
	0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0x55,
	0xFF, 0xFF, 0xAA,
	0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00,
	0x00, 0x00, 0x55,
	0x00, 0x00, 0xAA,
	0x00, 0x00, 0xFF,
	0x00, 0x55, 0x00,
	0x00, 0x55, 0x55,
	0x00, 0x55, 0xAA,
	0x00, 0x55, 0xFF,
	0x00, 0xAA, 0x00,
	0x00, 0xAA, 0x55,
	0x00, 0xAA, 0xAA,
	0x00, 0xAA, 0xFF,
	0x00, 0xFF, 0x00,
	0x00, 0xFF, 0x55,
	0x00, 0xFF, 0xAA,
	0x00, 0xFF, 0xFF,
	0x55, 0x00, 0x00,
	0x55, 0x00, 0x55,
	0x55, 0x00, 0xAA,
	0x55, 0x00, 0xFF,
	0x55, 0x55, 0x00,
	0x55, 0x55, 0x55,
	0x55, 0x55, 0xAA,
	0x55, 0x55, 0xFF,
	0x55, 0xAA, 0x00,
	0x55, 0xAA, 0x55,
	0x55, 0xAA, 0xAA,
	0x55, 0xAA, 0xFF,
	0x55, 0xFF, 0x00,
	0x55, 0xFF, 0x55,
	0x55, 0xFF, 0xAA,
	0x55, 0xFF, 0xFF,
	0xAA, 0x00, 0x00,
	0xAA, 0x00, 0x55,
	0xAA, 0x00, 0xAA,
	0xAA, 0x00, 0xFF,
	0xAA, 0x55, 0x00,
	0xAA, 0x55, 0x55,
	0xAA, 0x55, 0xAA,
	0xAA, 0x55, 0xFF,
	0xAA, 0xAA, 0x00,
	0xAA, 0xAA, 0x55,
	0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xFF,
	0xAA, 0xFF, 0x00,
	0xAA, 0xFF, 0x55,
	0xAA, 0xFF, 0xAA,
	0xAA, 0xFF, 0xFF,
	0xFF, 0x00, 0x00,
	0xFF, 0x00, 0x55,
	0xFF, 0x00, 0xAA,
	0xFF, 0x00, 0xFF,
	0xFF, 0x55, 0x00,
	0xFF, 0x55, 0x55,
	0xFF, 0x55, 0xAA,
	0xFF, 0x55, 0xFF,
	0xFF, 0xAA, 0x00,
	0xFF, 0xAA, 0x55,
	0xFF, 0xAA, 0xAA,
	0xFF, 0xAA, 0xFF,
	0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0x55,
	0xFF, 0xFF, 0xAA,
	0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00,
	0x00, 0x00, 0x55,
	0x00, 0x00, 0xAA,
	0x00, 0x00, 0xFF,
	0x00, 0x55, 0x00,
	0x00, 0x55, 0x55,
	0x00, 0x55, 0xAA,
	0x00, 0x55, 0xFF,
	0x00, 0xAA, 0x00,
	0x00, 0xAA, 0x55,
	0x00, 0xAA, 0xAA,
	0x00, 0xAA, 0xFF,
	0x00, 0xFF, 0x00,
	0x00, 0xFF, 0x55,
	0x00, 0xFF, 0xAA,
	0x00, 0xFF, 0xFF,
	0x55, 0x00, 0x00,
	0x55, 0x00, 0x55,
	0x55, 0x00, 0xAA,
	0x55, 0x00, 0xFF,
	0x55, 0x55, 0x00,
	0x55, 0x55, 0x55,
	0x55, 0x55, 0xAA,
	0x55, 0x55, 0xFF,
	0x55, 0xAA, 0x00,
	0x55, 0xAA, 0x55,
	0x55, 0xAA, 0xAA,
	0x55, 0xAA, 0xFF,
	0x55, 0xFF, 0x00,
	0x55, 0xFF, 0x55,
	0x55, 0xFF, 0xAA,
	0x55, 0xFF, 0xFF,
	0xAA, 0x00, 0x00,
	0xAA, 0x00, 0x55,
	0xAA, 0x00, 0xAA,
	0xAA, 0x00, 0xFF,
	0xAA, 0x55, 0x00,
	0xAA, 0x55, 0x55,
	0xAA, 0x55, 0xAA,
	0xAA, 0x55, 0xFF,
	0xAA, 0xAA, 0x00,
	0xAA, 0xAA, 0x55,
	0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xFF,
	0xAA, 0xFF, 0x00,
	0xAA, 0xFF, 0x55,
	0xAA, 0xFF, 0xAA,
	0xAA, 0xFF, 0xFF,
	0xFF, 0x00, 0x00,
	0xFF, 0x00, 0x55,
	0xFF, 0x00, 0xAA,
	0xFF, 0x00, 0xFF,
	0xFF, 0x55, 0x00,
	0xFF, 0x55, 0x55,
	0xFF, 0x55, 0xAA,
	0xFF, 0x55, 0xFF,
	0xFF, 0xAA, 0x00,
	0xFF, 0xAA, 0x55,
	0xFF, 0xAA, 0xAA,
	0xFF, 0xAA, 0xFF,
	0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0x55,
	0xFF, 0xFF, 0xAA,
	0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00,
	0x00, 0x00, 0x55,
	0x00, 0x00, 0xAA,
	0x00, 0x00, 0xFF,
	0x00, 0x55, 0x00,
	0x00, 0x55, 0x55,
	0x00, 0x55, 0xAA,
	0x00, 0x55, 0xFF,
	0x00, 0xAA, 0x00,
	0x00, 0xAA, 0x55,
	0x00, 0xAA, 0xAA,
	0x00, 0xAA, 0xFF,
	0x00, 0xFF, 0x00,
	0x00, 0xFF, 0x55,
	0x00, 0xFF, 0xAA,
	0x00, 0xFF, 0xFF,
	0x55, 0x00, 0x00,
	0x55, 0x00, 0x55,
	0x55, 0x00, 0xAA,
	0x55, 0x00, 0xFF,
	0x55, 0x55, 0x00,
	0x55, 0x55, 0x55,
	0x55, 0x55, 0xAA,
	0x55, 0x55, 0xFF,
	0x55, 0xAA, 0x00,
	0x55, 0xAA, 0x55,
	0x55, 0xAA, 0xAA,
	0x55, 0xAA, 0xFF,
	0x55, 0xFF, 0x00,
	0x55, 0xFF, 0x55,
	0x55, 0xFF, 0xAA,
	0x55, 0xFF, 0xFF,
	0xAA, 0x00, 0x00,
	0xAA, 0x00, 0x55,
	0xAA, 0x00, 0xAA,
	0xAA, 0x00, 0xFF,
	0xAA, 0x55, 0x00,
	0xAA, 0x55, 0x55,
	0xAA, 0x55, 0xAA,
	0xAA, 0x55, 0xFF,
	0xAA, 0xAA, 0x00,
	0xAA, 0xAA, 0x55,
	0xAA, 0xAA, 0xAA,
	0xAA, 0xAA, 0xFF,
	0xAA, 0xFF, 0x00,
	0xAA, 0xFF, 0x55,
	0xAA, 0xFF, 0xAA,
	0xAA, 0xFF, 0xFF,
	0xFF, 0x00, 0x00,
	0xFF, 0x00, 0x55,
	0xFF, 0x00, 0xAA,
	0xFF, 0x00, 0xFF,
	0xFF, 0x55, 0x00,
	0xFF, 0x55, 0x55,
	0xFF, 0x55, 0xAA,
	0xFF, 0x55, 0xFF,
	0xFF, 0xAA, 0x00,
	0xFF, 0xAA, 0x55,
	0xFF, 0xAA, 0xAA,
	0xFF, 0xAA, 0xFF,
	0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0x55,
	0xFF, 0xFF, 0xAA,
	0xFF, 0xFF, 0xFF,
};


#define HEAP_CAPACITY (8192*4096)
// 32MB (8192 x 4KB pages)
char heap[HEAP_CAPACITY];
size_t heap_size = 0;

void* heap_alloc(size_t size){
    if(heap_size + size > HEAP_CAPACITY){
        printf("[ERROR] Trying to allocate %d bytes from heap!\n",size);
        return (void*)NULL;
    }
    void* result = heap + heap_size;
    heap_size += size;
    return result;
}

void* heap_free(void* ptr){
    printf("[ERROR] heap_free is not implemented!\n");
}

uint8_t charset[8][128] = {   // charset line data
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x66,0x66,0x18,0x62,0x3c,0x06,0x0c,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x18,0x3c,0x3c,0x06,0x7e,0x3c,0x7e,0x3c,0x3c,0x00,0x00,0x0e,0x00,0x70,0x3c,0x3c,0x18,0x7c,0x3c,0x78,0x7e,0x7e,0x3c,0x66,0x3c,0x1e,0x66,0x60,0x63,0x66,0x3c,0x7c,0x3c,0x7c,0x3c,0x7e,0x66,0x66,0x63,0x66,0x66,0x7e,0x3c,0x00,0x3c,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e,0x18,0x70,0x00,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x66,0x66,0x3e,0x66,0x66,0x0c,0x18,0x18,0x66,0x18,0x00,0x00,0x00,0x03,0x66,0x18,0x66,0x66,0x0e,0x60,0x66,0x66,0x66,0x66,0x00,0x00,0x18,0x00,0x18,0x66,0x66,0x3c,0x66,0x66,0x6c,0x60,0x60,0x66,0x66,0x18,0x0c,0x6c,0x60,0x77,0x76,0x66,0x66,0x66,0x66,0x66,0x18,0x66,0x66,0x63,0x66,0x66,0x06,0x30,0x60,0x0c,0x18,0x00,0x66,0x00,0x60,0x00,0x06,0x00,0x0e,0x00,0x60,0x18,0x06,0x60,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x00,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x66,0xff,0x60,0x0c,0x3c,0x18,0x30,0x0c,0x3c,0x18,0x00,0x00,0x00,0x06,0x6e,0x38,0x06,0x06,0x1e,0x7c,0x60,0x0c,0x66,0x66,0x18,0x18,0x30,0x7e,0x0c,0x06,0x6e,0x66,0x66,0x60,0x66,0x60,0x60,0x60,0x66,0x18,0x0c,0x78,0x60,0x7f,0x7e,0x66,0x66,0x66,0x66,0x60,0x18,0x66,0x66,0x63,0x3c,0x66,0x0c,0x30,0x30,0x0c,0x3c,0x00,0x6e,0x3c,0x60,0x3c,0x06,0x3c,0x18,0x3e,0x60,0x00,0x00,0x60,0x18,0x66,0x7c,0x3c,0x7c,0x3e,0x7c,0x3e,0x7e,0x66,0x66,0x63,0x66,0x66,0x7e,0x18,0x18,0x18,0x00,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x66,0x3c,0x18,0x38,0x00,0x30,0x0c,0xff,0x7e,0x00,0x7e,0x00,0x0c,0x76,0x18,0x0c,0x1c,0x66,0x06,0x7c,0x18,0x3c,0x3e,0x00,0x00,0x60,0x00,0x06,0x0c,0x6e,0x7e,0x7c,0x60,0x66,0x78,0x78,0x6e,0x7e,0x18,0x0c,0x70,0x60,0x6b,0x7e,0x66,0x7c,0x66,0x7c,0x3c,0x18,0x66,0x66,0x6b,0x18,0x3c,0x18,0x30,0x18,0x0c,0x7e,0x00,0x6e,0x06,0x7c,0x60,0x3e,0x66,0x3e,0x66,0x7c,0x38,0x06,0x6c,0x18,0x7f,0x66,0x66,0x66,0x66,0x66,0x60,0x18,0x66,0x66,0x6b,0x3c,0x66,0x0c,0x70,0x18,0x0e,0x3b,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x06,0x30,0x67,0x00,0x30,0x0c,0x3c,0x18,0x00,0x00,0x00,0x18,0x66,0x18,0x30,0x06,0x7f,0x06,0x66,0x18,0x66,0x06,0x00,0x00,0x30,0x7e,0x0c,0x18,0x60,0x66,0x66,0x60,0x66,0x60,0x60,0x66,0x66,0x18,0x0c,0x78,0x60,0x63,0x6e,0x66,0x60,0x66,0x78,0x06,0x18,0x66,0x66,0x7f,0x3c,0x18,0x30,0x30,0x0c,0x0c,0x18,0x00,0x60,0x3e,0x66,0x60,0x66,0x7e,0x18,0x66,0x66,0x18,0x06,0x78,0x18,0x7f,0x66,0x66,0x66,0x66,0x60,0x3c,0x18,0x66,0x66,0x7f,0x18,0x66,0x18,0x18,0x18,0x18,0x6e,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0x7c,0x66,0x66,0x00,0x18,0x18,0x66,0x18,0x18,0x00,0x18,0x30,0x66,0x18,0x60,0x66,0x06,0x66,0x66,0x18,0x66,0x66,0x18,0x18,0x18,0x00,0x18,0x00,0x66,0x66,0x66,0x66,0x6c,0x60,0x60,0x66,0x66,0x18,0x6c,0x6c,0x60,0x63,0x66,0x66,0x60,0x3c,0x6c,0x66,0x18,0x66,0x3c,0x77,0x66,0x18,0x60,0x30,0x06,0x0c,0x18,0x00,0x66,0x66,0x66,0x60,0x66,0x60,0x18,0x3e,0x66,0x18,0x06,0x6c,0x18,0x6b,0x66,0x66,0x7c,0x3e,0x60,0x06,0x18,0x66,0x3c,0x3e,0x3c,0x3e,0x30,0x18,0x18,0x18,0x00,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x66,0x18,0x46,0x3f,0x00,0x0c,0x30,0x00,0x00,0x18,0x00,0x18,0x60,0x3c,0x7e,0x7e,0x3c,0x06,0x3c,0x3c,0x18,0x3c,0x3c,0x00,0x18,0x0e,0x00,0x70,0x18,0x3c,0x66,0x7c,0x3c,0x78,0x7e,0x60,0x3c,0x66,0x3c,0x38,0x66,0x7e,0x63,0x66,0x3c,0x60,0x0e,0x66,0x3c,0x18,0x3c,0x18,0x63,0x66,0x18,0x7e,0x3c,0x03,0x3c,0x18,0x00,0x3c,0x3e,0x7c,0x3c,0x3e,0x3c,0x18,0x06,0x66,0x3c,0x06,0x66,0x3c,0x63,0x66,0x3c,0x60,0x06,0x60,0x7c,0x0e,0x3e,0x18,0x36,0x66,0x0c,0x7e,0x0e,0x18,0x70,0x00,0xff,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x60,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x18,0x00,0x00,0xff,
  };

void vga_clear(){
	for (size_t j = 0; j < 200; j++)
	{
		for (size_t i = 0; i < 320; i++)
		{
			*(VRAM + i + j * 320) = 0;
		}
	}
	
}

typedef enum vga_mode_t {PALLETE, RGBA8888}vga_mode_t;

typedef struct cursor_t
{
	uint32_t xres, yres;
	vga_mode_t mode;
	int x0, y0;
	int x, y;
}cursor_t;


void vga_put_pixel(uint32_t x, uint32_t y, cursor_t* pCursor, uint32_t color){
	if(pCursor->mode == PALLETE){
		*(VRAM + (pCursor->x + x) + (pCursor->y + y) * pCursor->xres) =  color & 0xff;
	}
	else if(pCursor->mode == RGBA8888){
		((uint32_t*) VRAM)[(pCursor->x + x) + (pCursor->y + y) * pCursor->xres] =  color;
	}
}

void vga_putc(cursor_t* pCursor, uint8_t c, uint32_t color){
	for(uint8_t j=0; j<8; j++)
    {
      	uint8_t cs = charset[j][c];
		for (uint8_t i = 0; i < 8; i++)
		{
			uint8_t bit = ((cs >> (7-i)) & 1);
			if(bit)
				vga_put_pixel(i,j,pCursor,color);
		}
    }
	pCursor->x += 8;
	if(c == '\n'){
		pCursor->x = pCursor->x0;
		pCursor->y += 8;
	}
}

void vga_puts(cursor_t* pCursor, char* string, uint32_t color){
	pCursor->x = pCursor->x0;
	pCursor->y = pCursor->y0;
	while(*string){
		vga_putc(pCursor, *string++, color);
	}
}

vga_flush(cursor_t* pCursor){
	pCursor->x = pCursor->x0;
	pCursor->y = pCursor->y0;
}

/*
int os_main(void) {
    lib_puts("Initializing PCIE Interface...\r\n");

    volatile uint32_t* bar[6] = {0,0,0,0,0,0};

    // Setup bar0
    uint32_t bar0_offset = 0x10;
    pci_config_write32(0, 1, 0, bar0_offset, (VRAM_BASE + 8));
    bar[0] = (volatile uint32_t*)pci_config_read32(0, 1, 0, bar0_offset);

    // Setup bar1
    uint32_t bar2_offset = 0x18;
    pci_config_write32(0, 1, 0, bar2_offset, MMIO_BASE);
    bar[2] = (volatile uint32_t*)pci_config_read32(0, 1, 0, bar2_offset);

    // Enable memory access
    uint32_t reg = pci_config_read32(0, 1, 0, 0x04) | 0x02;
    pci_config_write32(0, 1, 0, 0x04, reg);
    reg = pci_config_read32(0, 1, 0, 0x04);

    printf("PCIE BAR mmap:\n");
    for (size_t i = 0; i < sizeof(bar)/sizeof(bar[0]); i++)
    {
        printf(" BAR%d: [0x%08x]\n", i, (uint32_t)bar[i]);
    }

    printf("Setting video mode: \"13h\"...\n");
   
    // Set up video mode somehow
    write16(MMIO_BASE + 0x508, 0x60);

    printf("Writing \"13h\" mode regs...\n");
 
    // Set Mode 13h by hand
    uint32_t c0 = 0xC0;
    uint32_t base_ptr = MMIO_BASE + (0x400 - c0);
    
    for(int i = 0; i < sizeof(mode_13h_regs)/sizeof(mode_13h_regs[0]); i++){
        uint8_t address = mode_13h_regs[i].address;
        int8_t index = (int8_t)mode_13h_regs[i].index;
        uint8_t data = mode_13h_regs[i].data;

        uint32_t ptr = base_ptr + address;

        if(address == 0){
            // Done ?
            break;
        }
        else if(address < c0){
            // The attribute controller is a special case
            uint8_t zero = read8(base_ptr+0xDA);
            write8(ptr+0, index);
            write8(ptr+0, data);
        }
        else if(index < 0){
            // External registers are also special
			// but not as special as the attribute controller
            write8(ptr+0, data);
        }
        else{
            // Normal case
            write8(ptr+0, index);
            write8(ptr+1, data);
        }
    }
    
    printf("Writing pallete...\n");

    *((volatile uint8_t*)MMIO + 0x408) = 0;
    for (size_t i = 0; i < sizeof(initial_palette); i++){
        write8(MMIO_BASE+0x409, initial_palette[i]);
    }

	printf("Changed to graphics mode. Check VGA Device!\n");

	cursor_t cursor = {320, 200, PALLETE, 0, 0, 0, 0};
	char string[256];
	uint8_t sz = 0;

    while (1){
		vga_flush(&cursor);
		vga_puts(&cursor, "Hello OS!\n", 0xff);
		vga_puts(&cursor, "root: ", 0xff);
		vga_puts(&cursor, string, 0xff);
		while(1){
			char c = lib_getc();
			if(c == 0xff) break;
			string[sz++] = c;
			printf("got char: %d, string: %s, size: %d\n", c, string, sz);
		}
    }
	
    return 0;
}
*/

#define VBE_DISPI_INDEX_ID               0x0
#define VBE_DISPI_INDEX_XRES             0x1
#define VBE_DISPI_INDEX_YRES             0x2
#define VBE_DISPI_INDEX_BPP              0x3
#define VBE_DISPI_INDEX_ENABLE           0x4
#define VBE_DISPI_INDEX_BANK             0x5
#define VBE_DISPI_INDEX_VIRT_WIDTH       0x6
#define VBE_DISPI_INDEX_VIRT_HEIGHT      0x7
#define VBE_DISPI_INDEX_X_OFFSET         0x8
#define VBE_DISPI_INDEX_Y_OFFSET         0x9
#define VBE_DISPI_INDEX_VIDEO_MEMORY_64K 0xa

#define VBE_DISPI_ID0                    0xB0C0
#define VBE_DISPI_ID1                    0xB0C1
#define VBE_DISPI_ID2                    0xB0C2
#define VBE_DISPI_ID3                    0xB0C3
#define VBE_DISPI_ID4                    0xB0C4
#define VBE_DISPI_ID5                    0xB0C5

#define VBE_DISPI_DISABLED               0x00
#define VBE_DISPI_ENABLED                0x01
#define VBE_DISPI_GETCAPS                0x02
#define VBE_DISPI_8BIT_DAC               0x20
#define VBE_DISPI_LFB_ENABLED            0x40
#define VBE_DISPI_NOCLEARMEM             0x80

#define VBE_DISPI_INDEX_VIDEO_MEMORY_64K 0xa

static void bochs_vga_writeb(uint32_t mmio, uint16_t ioport, uint8_t val)
{
	if (ioport < 0x3c0 || ioport > 0x3df)
		return;

	int offset = ioport - 0x3c0 + 0x400;
	write8(mmio + offset, val);
}

static uint16_t bochs_dispi_read(uint32_t mmio, uint16_t reg)
{
	uint16_t ret = 0;

	uint32_t offset = 0x500 + (reg << 1);
	ret = read16(mmio + offset);

	return ret;
}

static void bochs_dispi_write(uint32_t mmio, uint16_t reg, uint16_t val)
{
	uint32_t offset = 0x500 + (reg << 1);
	write16(mmio + offset, val);
}

int os_main(void){
	uart_init();

	lib_puts("Initializing PCIE Interface...\r\n");
	volatile uint32_t* bar[6] = {0,0,0,0,0,0};

	struct pci_dev dev;
	dev.bus = 0;
	dev.slot = 1;
	dev.devfn = 0;
	dev.vendor = 0x1234;
	dev.device = 0x1111;
	
	// Setup bar0
	uint32_t bar0_offset = 0x10;
	size_t bar0_size = pci_resource_len(&dev, 0);
	pci_config_write32(0, 1, 0, bar0_offset, (VRAM_BASE + 8));
	bar[0] = (volatile uint32_t*)pci_config_read32(0, 1, 0, bar0_offset);
	printf("BAR0: [%x-%x] %d MB\n", bar[0], bar[0]+bar0_size, bar0_size / (1024*1024));

	// Setup bar1
	uint32_t bar2_offset = 0x18;
	size_t bar2_size = pci_resource_len(&dev, 2);
	pci_config_write32(0, 1, 0, bar2_offset, MMIO_BASE);
	bar[2] = (volatile uint32_t*)pci_config_read32(0, 1, 0, bar2_offset);
	printf("BAR2: [%x-%x] %d bytes\n", bar[2], bar[2]+bar0_size, bar2_size);

	// Enable memory access
	uint32_t reg = pci_config_read32(0, 1, 0, 0x04) | 0x02;
	pci_config_write32(0, 1, 0, 0x04, reg);
	//reg = pci_config_read32(0, 1, 0, 0x04);

	printf("PCIE BAR mmap:\n");
	for (size_t i = 0; i < sizeof(bar)/sizeof(bar[0]); i++)
	{
		printf(" BAR%d: [0x%08x]\n", i, (uint32_t)bar[i]);
	}

	uint16_t xres = 1024;
	uint16_t yres = 768;
	uint16_t yres_virtual = yres;
	uint32_t bpp = 32;
	
	bochs_vga_writeb(MMIO_BASE, 0x3c0, 0x20); /* unblank */

	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_ENABLE,      0);
	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_BPP,         bpp);
	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_XRES,        xres);
	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_YRES,        yres);
	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_BANK,        0);
	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_VIRT_WIDTH,  xres);
	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_VIRT_HEIGHT, yres_virtual);
	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_X_OFFSET,    0);
	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_Y_OFFSET,    0);

	bochs_dispi_write(MMIO_BASE, VBE_DISPI_INDEX_ENABLE, VBE_DISPI_ENABLED | VBE_DISPI_LFB_ENABLED);

	cursor_t cursor = {xres, yres, RGBA8888, 0, 0, 0, 0};

	char* str = "  _____              __   ____\n"
	" /\\  __`\\          /'__`\\/\\  _`\\\n"
	" \\ \\ \\/\\ \\   __  _/\\ \\/\\ \\ \\,\\ \\_\\\n"
	"  \\ \\ \\ \\ \\ /\\ \\/'\\ \\ \\ \\ \\/_\\__ \\\n"
	"   \\ \\ \\_\\ \\/>  </\\ \\ \\_\\ \\/\\ \\ \\ \\\n"
	"    \\ \\_____\\/\\_/\\_\\ \\____/\\ `\\____\\\n"
	"     \\/_____/\\//\\/_/ \\/___/  \\/_____/\n"
	"\n"
	"  ____________________________________\n"
	"/\\                                    \\\n"
	"\\ \\       OxOS - Version 0.0.001       \\\n"
	" \\ \\     Paulo-D2000 & LuanOldCode      \\\n"
	"  \\ \\____________________________________\\\n"
	"   \\/____________________________________/";

	int xvel = 4, yvel = 4;
	while (1){
		vga_flush(&cursor);

		for (size_t j = 0; j < yres; j++)
		{
			for (size_t i = 0; i < xres; i++)
			{
				uint8_t r = (255*i) / xres;
				uint8_t g = (255*j) / yres;
				uint8_t b = 64;
				uint8_t a = 255;
				uint32_t pixel = (a << 24) | (r << 16) | (g << 8) | b;
				((uint32_t*)VRAM)[i+j*xres] = pixel;
			}
		}

		vga_puts(&cursor, str, 0xffffffff);
	
		for (size_t i = 0; i < 8192; i++)
		{
			printf("sleep...\n");
		}

		if(cursor.x > xres){
			cursor.x0 = xres - (cursor.x - cursor.x0);
			xvel *= -1;
		}
		else if(cursor.x0 < 0){
			cursor.x0 = 0;
			xvel *= -1;
		}
		else
			cursor.x0 += xvel;

		if(cursor.y > (yres-8)){
			cursor.y0 = (yres-8) - (cursor.y - cursor.y0);
			yvel *= -1;
		}
		else if(cursor.y0 < 0){
			cursor.y0 = 0;
			yvel *= -1;
		}
		else
			cursor.y0 += yvel;
	}

	return 0;
}